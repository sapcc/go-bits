// SPDX-FileCopyrightText: 2024 SAP SE or an SAP affiliate company
// SPDX-License-Identifier: Apache-2.0

/*
Package audittools provides a toolkit for establishing a connection to
a RabbitMQ server (with sane defaults) and publishing audit messages in the CADF format to it.
Events are serialized into the subset of CADF that Hermes (https://github.com/sapcc/hermes) can consume.

To use this library, build an Auditor object, then use its Record() function to push events.
*/
package audittools

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net"
	"net/url"
	"os"
	"strconv"
	"testing"

	"github.com/prometheus/client_golang/prometheus"

	"github.com/sapcc/go-api-declarations/cadf"

	"github.com/sapcc/go-bits/assert"
	"github.com/sapcc/go-bits/internal"
	"github.com/sapcc/go-bits/logg"
	"github.com/sapcc/go-bits/osext"
)

const (
	// eventBufferSize is the maximum number of events that can be buffered in memory
	// when the RabbitMQ connection is unavailable and the backing store is full or unavailable.
	// 20 events provides enough buffering for transient spikes without excessive memory usage.
	// When this limit is reached, Record() will block to apply backpressure and prevent data loss.
	eventBufferSize = 20
)

// Auditor is a high-level interface for audit event acceptors.
// In a real process, use NewAuditor() or NewNullAuditor() depending on whether you have RabbitMQ client credentials.
// In a test scenario, use NewMockAuditor() to get an assertable mock implementation.
type Auditor interface {
	Record(Event)
}

////////////////////////////////////////////////////////////////////////////////
// type standardAuditor

// AuditorOpts contains options for NewAuditor().
type AuditorOpts struct {
	// Required. Identifies the current process within the events sent by it.
	// The Observer.ID field should be set to a UUID, such as those generated by GenerateUUID().
	Observer Observer

	// Optional. If given, RabbitMQ connection options will be read from the following environment variables:
	//   - "${PREFIX}_HOSTNAME" (defaults to "localhost")
	//   - "${PREFIX}_PORT" (defaults to "5672")
	//   - "${PREFIX}_USERNAME" (defaults to "guest")
	//   - "${PREFIX}_PASSWORD" (defaults to "guest")
	//   - "${PREFIX}_QUEUE_NAME" (required)
	//   - "${PREFIX}_BACKING_STORE" (optional, JSON configuration for backing store)
	EnvPrefix string

	// Required if EnvPrefix is empty, ignored otherwise.
	// Contains the RabbitMQ connection options that would otherwise be read from environment variables.
	ConnectionURL string
	QueueName     string

	// Optional. If given, the Auditor will register its Prometheus metrics with this registry instead of the default registry.
	// The following metrics are registered:
	//   - "audittools_successful_submissions" (counter, no labels)
	//   - "audittools_failed_submissions" (counter, no labels)
	Registry prometheus.Registerer

	// Optional. If given, this BackingStore instance will be used directly.
	// Otherwise, a backing store will be created from BackingStoreFactories based on
	// the JSON configuration in environment variable "${PREFIX}_BACKING_STORE".
	BackingStore BackingStore

	// Optional. Map of backing store type IDs to factory functions.
	// Enables per-auditor backing store configuration through environment variables.
	// Applications can register custom implementations alongside built-in types.
	//
	// Example usage:
	//   auditor, err := NewAuditor(ctx, AuditorOpts{
	//       EnvPrefix: "MYAPP_AUDIT_RABBITMQ",
	//       BackingStoreFactories: map[string]BackingStoreFactory{
	//           "file":   NewFileBackingStore,
	//           "memory": NewInMemoryBackingStore,
	//           "sql":    SQLBackingStoreFactoryWithDB(db),
	//       },
	//   })
	BackingStoreFactories map[string]BackingStoreFactory
}

func (opts AuditorOpts) getConnectionOptions() (rabbitURL url.URL, queueName string, err error) {
	if opts.EnvPrefix == "" {
		return opts.getExplicitConnectionOptions()
	}
	return opts.getEnvConnectionOptions()
}

func (opts AuditorOpts) getExplicitConnectionOptions() (url.URL, string, error) {
	if opts.ConnectionURL == "" {
		return url.URL{}, "", errors.New("missing required value: AuditorOpts.ConnectionURL")
	}
	if opts.QueueName == "" {
		return url.URL{}, "", errors.New("missing required value: AuditorOpts.QueueName")
	}

	rabbitURL, err := url.Parse(opts.ConnectionURL)
	if err != nil {
		return url.URL{}, "", fmt.Errorf("while parsing AuditorOpts.ConnectionURL (%q): %w", opts.ConnectionURL, err)
	}

	return *rabbitURL, opts.QueueName, nil
}

func (opts AuditorOpts) getEnvConnectionOptions() (url.URL, string, error) {
	queueName, err := osext.NeedGetenv(opts.EnvPrefix + "_QUEUE_NAME")
	if err != nil {
		return url.URL{}, "", err
	}

	hostname := osext.GetenvOrDefault(opts.EnvPrefix+"_HOSTNAME", "localhost")
	port, err := opts.parsePort()
	if err != nil {
		return url.URL{}, "", err
	}

	username := osext.GetenvOrDefault(opts.EnvPrefix+"_USERNAME", "guest")
	password := osext.GetenvOrDefault(opts.EnvPrefix+"_PASSWORD", "guest")

	rabbitURL := url.URL{
		Scheme: "amqp",
		Host:   net.JoinHostPort(hostname, strconv.Itoa(port)),
		User:   url.UserPassword(username, password),
		Path:   "/",
	}

	return rabbitURL, queueName, nil
}

func (opts AuditorOpts) parsePort() (int, error) {
	portStr := osext.GetenvOrDefault(opts.EnvPrefix+"_PORT", "5672")
	port, err := strconv.Atoi(portStr)
	if err != nil {
		return 0, fmt.Errorf("invalid value for %s_PORT: %w", opts.EnvPrefix, err)
	}
	return port, nil
}

type standardAuditor struct {
	Observer  Observer
	EventSink chan<- cadf.Event
}

// NewAuditor builds an Auditor connected to a RabbitMQ instance, using the provided configuration.
func NewAuditor(ctx context.Context, opts AuditorOpts) (Auditor, error) {
	if err := opts.validateObserver(); err != nil {
		return nil, err
	}

	successCounter, failureCounter := createAndRegisterMetrics(opts.Registry)

	rabbitURL, queueName, err := opts.getConnectionOptions()
	if err != nil {
		return nil, err
	}

	backingStore, err := opts.createBackingStore()
	if err != nil {
		return nil, err
	}

	eventChan := make(chan cadf.Event, eventBufferSize)
	go auditTrail{
		EventSink:           eventChan,
		OnSuccessfulPublish: func() { successCounter.Inc() },
		OnFailedPublish:     func() { failureCounter.Inc() },
		BackingStore:        backingStore,
	}.Commit(ctx, rabbitURL, queueName)

	return &standardAuditor{
		Observer:  opts.Observer,
		EventSink: eventChan,
	}, nil
}

func (opts AuditorOpts) validateObserver() error {
	if opts.Observer.TypeURI == "" {
		return errors.New("missing required value: AuditorOpts.Observer.TypeURI")
	}
	if opts.Observer.Name == "" {
		return errors.New("missing required value: AuditorOpts.Observer.Name")
	}
	if opts.Observer.ID == "" {
		return errors.New("missing required value: AuditorOpts.Observer.ID")
	}
	return nil
}

func createAndRegisterMetrics(registry prometheus.Registerer) (success, failure prometheus.Counter) {
	success = prometheus.NewCounter(prometheus.CounterOpts{
		Name: "audittools_successful_submissions",
		Help: "Counter for successful audit event submissions to the Hermes RabbitMQ server.",
	})
	failure = prometheus.NewCounter(prometheus.CounterOpts{
		Name: "audittools_failed_submissions",
		Help: "Counter for failed (but retryable) audit event submissions to the Hermes RabbitMQ server.",
	})

	success.Add(0)
	failure.Add(0)

	if registry == nil {
		prometheus.MustRegister(success, failure)
	} else {
		registry.MustRegister(success, failure)
	}

	return success, failure
}

func (opts AuditorOpts) createBackingStore() (BackingStore, error) {
	if opts.BackingStore != nil {
		return opts.BackingStore, nil
	}

	configJSON := ""
	if opts.EnvPrefix != "" {
		configJSON = os.Getenv(opts.EnvPrefix + "_BACKING_STORE")
	}

	// Default to in-memory store for zero-configuration operation during transient RabbitMQ outages.
	if configJSON == "" {
		configJSON = `{"type":"memory","params":{"max_events":1000}}`
	}

	var cfg struct {
		Type   string          `json:"type"`
		Params json.RawMessage `json:"params"`
	}
	if err := json.Unmarshal([]byte(configJSON), &cfg); err != nil {
		return nil, fmt.Errorf("audittools: invalid backing store config: %w", err)
	}

	if len(cfg.Params) == 0 {
		cfg.Params = json.RawMessage("{}")
	}

	if opts.BackingStoreFactories == nil {
		return nil, errors.New("audittools: no backing store factories provided and no BackingStore instance given")
	}

	factory, ok := opts.BackingStoreFactories[cfg.Type]
	if !ok {
		availableTypes := make([]string, 0, len(opts.BackingStoreFactories))
		for k := range opts.BackingStoreFactories {
			availableTypes = append(availableTypes, k)
		}
		return nil, fmt.Errorf("audittools: unknown backing store type %q (available: %v)", cfg.Type, availableTypes)
	}

	return factory(cfg.Params, opts)
}

// Record implements the Auditor interface.
func (a *standardAuditor) Record(event Event) {
	a.EventSink <- event.ToCADF(a.Observer.ToCADF())
}

////////////////////////////////////////////////////////////////////////////////
// type nullAuditor

// NewNullAuditor returns an Auditor that does nothing (except produce a debug log of the discarded event).
// This is only intended to be used for non-productive deployments without a Hermes instance.
func NewNullAuditor() Auditor {
	return nullAuditor{}
}

type nullAuditor struct{}

// Record implements the Auditor interface.
func (nullAuditor) Record(event Event) {
	if logg.ShowDebug {
		msg, err := json.Marshal(event.ToCADF(cadf.Resource{}))
		if err == nil {
			logg.Debug("audit event received: %s", string(msg))
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
// type MockAuditor

// MockAuditor is a test double that satisfies the Auditor interface.
// It stores events sent to it and provides test assertions on those events.
type MockAuditor struct {
	events []cadf.Event
}

// NewMockAuditor constructs a new MockAuditor instance.
func NewMockAuditor() *MockAuditor {
	return &MockAuditor{}
}

// Record implements the Auditor interface.
func (a *MockAuditor) Record(event Event) {
	eventAsCADF := event.ToCADF(cadf.Resource{})
	a.events = append(a.events, a.normalize(eventAsCADF))
}

// ExpectEvents checks that the recorded events are equivalent to the supplied expectation.
// At the end of the call, the recording will be disposed, so the next ExpectEvents call will not check against the same events again.
//
// If you do not have a *testing.T (e.g. under Ginkgo), use func RecordedEvents instead.
func (a *MockAuditor) ExpectEvents(t *testing.T, expectedEvents ...cadf.Event) {
	t.Helper()
	if len(expectedEvents) == 0 {
		expectedEvents = nil
	} else {
		for idx, event := range expectedEvents {
			expectedEvents[idx] = a.normalize(event)
		}
	}
	assert.DeepEqual(t, "CADF events", a.events, expectedEvents)

	// reset state for next test
	a.events = nil
}

// RecordedEvents returns the list of recorded events.
// At the end of the call, the recording will be disposed, so the next RecordedEvents call will not see the same events again.
//
// This is intended for use with test assertion libraries where ExpectEvents does not work
// For Ginkgo/Gomega specifically, we recommend matching the event payloads with the gstruct submodule of gomega.
func (a *MockAuditor) RecordedEvents() []cadf.Event {
	result := a.events
	a.events = nil
	return result
}

// IgnoreEventsUntilNow clears the list of recorded events, so that the next
// ExpectEvents() or RecordedEvents() will only cover events generated after this point.
func (a *MockAuditor) IgnoreEventsUntilNow() {
	a.events = nil
}

func (a *MockAuditor) normalize(event cadf.Event) cadf.Event {
	// overwrite some attributes where we don't care about variance
	event.TypeURI = "http://schemas.dmtf.org/cloud/audit/1.0/event"
	event.ID = "00000000-0000-0000-0000-000000000000"
	event.EventTime = "2006-01-02T15:04:05.999999+00:00"
	event.EventType = "activity"
	if event.Initiator.TypeURI == internal.StandardUserInfoTypeURI {
		// we do not care about the Initiator unless it's a non-standard UserInfo
		event.Initiator = cadf.Resource{}
	}
	event.Observer = cadf.Resource{}
	return event
}
