// SPDX-FileCopyrightText: 2023 SAP SE or an SAP affiliate company
// SPDX-License-Identifier: Apache-2.0

package jobloop

import (
	"context"
	"fmt"
	"maps"

	"github.com/majewsky/gg/option"
	"github.com/prometheus/client_golang/prometheus"
)

// JobMetadata contains metadata and common configuration for a job. Types that
// implement the Job interface will usually be holding one of these.
type JobMetadata struct {
	// A readable name or short description for this job. This will be used in
	// log messages.
	ReadableName string
	// Whether it is safe to have multiple tasks running in parallel. If set to
	// false, the job will never select a new task before the previous task has
	// been fully processed, thus avoiding any concurrent processing of tasks.
	ConcurrencySafe bool

	// Metadata for the counter metric that will be emitted by the job.
	CounterOpts prometheus.CounterOpts
	// The labels of the counter metric. Besides the application-specific labels
	// listed here, the counter metric will always have the label "task_outcome"
	// with the possible values "success" and "failure". This label will be
	// filled by the job implementation.
	CounterLabels []string

	counter *prometheus.CounterVec
}

const (
	outcomeLabelName    = "task_outcome"
	outcomeValueSuccess = "success"
	outcomeValueFailure = "failure"
)

// Internal API for job implementations: Registers and initializes the
// CounterVec that is described by this JobMetadata.
func (m *JobMetadata) setup(registerer prometheus.Registerer) {
	if registerer == nil {
		registerer = prometheus.DefaultRegisterer
	}

	allLabelNames := append([]string{outcomeLabelName}, m.CounterLabels...)
	m.counter = prometheus.NewCounterVec(m.CounterOpts, allLabelNames)
	registerer.MustRegister(m.counter)

	// ensure that at least one timeseries for each outcome exists in this counter
	// (so that absence alerts are useful)
	labels := make(prometheus.Labels, len(m.CounterLabels)+1)
	for _, label := range m.CounterLabels {
		labels[label] = "unknown"
	}
	labels[outcomeLabelName] = outcomeValueSuccess
	m.counter.With(labels).Add(0)
	labels[outcomeLabelName] = "failure"
	m.counter.With(labels).Add(0)
}

// State associated with a task (a single run of a job).
// The job implementation can put a suitable payload in the type argument slot.
type taskContext[T any] struct {
	Payload T
	Labels  prometheus.Labels

	// slots that can optionally be filled by callbacks
	TaskDescription *option.Option[string]
}

// Internal API for job implementations: Constructs a taskContext with default
// values for all labels defined for this job's CounterVec.
func makeTaskContext[T any](m JobMetadata, cfg jobConfig) taskContext[T] {
	labels := make(prometheus.Labels, len(m.CounterLabels)+1)
	for _, label := range m.CounterLabels {
		labels[label] = "early-db-access"
	}
	maps.Copy(labels, cfg.PrefilledLabels)

	noTaskDescription := option.None[string]()
	return taskContext[T]{
		Labels:          labels,
		TaskDescription: &noTaskDescription,
		// Payload will be filled by the job implementation after this call
	}
}

// Unique key for Context.WithValue().
type taskDescriptionSlot struct{}

// Internal API for job implementations: Stores references to the fillable slots inside `ctx`.
// This allows the callback functions used by the job to use func DescribeTask().
func (tc taskContext[T]) attachToContext(ctx context.Context) context.Context {
	return context.WithValue(ctx, taskDescriptionSlot{}, tc.TaskDescription)
}

// DescribeTask provides a description of the current task for error messages generated by package jobloop.
// This must be called within a callback function held by a job instance, and `ctx` must be the context
// provided to that callback.
//
// The intention of this function is to reduce boilerplate in error return paths. For example, inside a job callback:
//
//	foo, err := computeFoo(ctx, obj)
//	if err != nil {
//		return fmt.Errorf("while running computations for object %q: %w", obj.Name, err)
//	}
//	bar, err := deriveBar(ctx, obj, foo)
//	if err != nil {
//		return fmt.Errorf("while running computations for object %q: %w", obj.Name, err)
//	}
//	err := storeBar(ctx, obj, bar)
//	if err != nil {
//		return fmt.Errorf("while running computations for object %q: %w", obj.Name, err)
//	}
//
// can be simplified to:
//
//	jobloop.DescribeTask(ctx, fmt.Sprintf("running computations for object %q", obj.Name)
//	foo, err := computeFoo(ctx, obj)
//	if err != nil {
//		return err
//	}
//	bar, err := deriveBar(ctx, obj, foo)
//	if err != nil {
//		return err
//	}
//	err := storeBar(ctx, obj, bar)
//	if err != nil {
//		return err
//	}
//
// Like in this example, the description should be written in the continuous tense (starting with a verb that ends in "-ing")
// in order to read well in the context of the generated error message.
//
// This function panics if `ctx` is not a context provided by package jobloop.
// This function is safe to call multiple times within the same job: Later calls overwrite the values provided by earlier calls.
func DescribeTask(ctx context.Context, desc string) {
	descSlot, ok := ctx.Value(taskDescriptionSlot{}).(*option.Option[string])
	if ok {
		*descSlot = option.Some(desc)
	} else {
		panic("not called within a go-bits/jobloop callback!")
	}
}

// Internal API for job implementations: Counts a finished or failed task.
// The "task_outcome" label will be set based on whether `err` is nil or not.
func (tc taskContext[T]) countTask(m JobMetadata, err error) {
	if err == nil {
		tc.Labels[outcomeLabelName] = outcomeValueSuccess
	} else {
		tc.Labels[outcomeLabelName] = "failure"
	}
	m.counter.With(tc.Labels).Inc()
}

// Internal API for job implementations: Enrich errors with additional error context if necessary.
// The `verb` argument describes which step of the task this error came from.
func (tc taskContext[T]) enrichError(verb string, err error, m JobMetadata, cfg jobConfig) error {
	if err == nil || !cfg.WantsExtraErrorContext {
		return err
	}

	return fmt.Errorf("could not %s task%s for job %q: %w",
		verb, cfg.PrefilledLabelsAsString(), m.ReadableName, err)
}
